
==================== FINAL INTERFACE ====================
2016-06-12 07:28:05.596311 UTC

interface main@main:Main 7103
  interface hash: 2ab2ac1ec4e4eff0b1a5358a4a541934
  ABI hash: 45b9cfd08a476c0fa97f764d514a4c4d
  export-list hash: d60da6f2da4bfeef6b9a3f7d209a2529
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: db54b3632fd09afba7c6a9a34e8e01c5
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.differential
  Main.epsilon
  Main.find_min
  Main.h
  Main.main
  Main.update
module dependencies:
package dependencies: Gradient-Method-Multivariate-0.1.0.0@Gradi_JbP0S2lxg7W18AWNIWptfS
                      base-4.8.2.0* ghc-prim-0.4.0.0 integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  Gradient-Method-Multivariate-0.1.0.0@Gradi_JbP0S2lxg7W18AWNIWptfS:Lib 88cdd508206407129c1e8f25884eac51
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.Tuple 012ad951a59a9d85fe1de36a2f012986
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Real 1281efa9baf803bc7859d7efb89a38b3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:System.IO 0899686bfc1d9ef72dff3de85e99862a
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
695ae6ef3ca9f58d3d0669f8d6cdfda8
  $w$supdate ::
    [GHC.Types.Double]
    -> GHC.Prim.Int# -> GHC.Types.Double -> [GHC.Types.Double]
  {- Arity: 3, Strictness: <L,U><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ w :: [GHC.Types.Double]
                   ww :: GHC.Prim.Int#
                   w1 :: GHC.Types.Double ->
                 let {
                   a :: GHC.Types.Double
                   = case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# ww 0) of wild1 {
                       GHC.Types.False
                       -> case w of wild {
                            [] -> case GHC.List.badHead ret_ty GHC.Types.Double of {}
                            : ipv ipv1
                            -> case ww of ds1 {
                                 DEFAULT
                                 -> case GHC.List.splitAt_$s$wsplitAt'
                                           @ GHC.Types.Double
                                           (GHC.Prim.-# ds1 1)
                                           ipv1 of ww1 { (#,#) ww2 ww3 ->
                                    case ww3 of wild2 {
                                      [] -> case GHC.List.badHead ret_ty GHC.Types.Double of {}
                                      : x ds2
                                      -> case x of wild3 { GHC.Types.D# x1 ->
                                         case w1 of wild4 { GHC.Types.D# y ->
                                         GHC.Types.D# (GHC.Prim.+## x1 y) } } } }
                                 1
                                 -> case ipv1 of wild2 {
                                      [] -> case GHC.List.badHead ret_ty GHC.Types.Double of {}
                                      : x ds2
                                      -> case x of wild3 { GHC.Types.D# x1 ->
                                         case w1 of wild4 { GHC.Types.D# y ->
                                         GHC.Types.D# (GHC.Prim.+## x1 y) } } } } }
                       GHC.Types.True
                       -> case w of wild {
                            [] -> case GHC.List.badHead ret_ty GHC.Types.Double of {}
                            : x ds1
                            -> case x of wild2 { GHC.Types.D# x1 ->
                               case w1 of wild3 { GHC.Types.D# y ->
                               GHC.Types.D# (GHC.Prim.+## x1 y) } } } }
                 } in
                 let {
                   a1 :: [GHC.Types.Double]
                   = case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# ww 0) of wild1 {
                       GHC.Types.False
                       -> case w of wild {
                            [] -> GHC.List.scanl2 @ GHC.Types.Double
                            : ipv ipv1
                            -> case ww of ds1 {
                                 DEFAULT
                                 -> case GHC.List.splitAt_$s$wsplitAt'
                                           @ GHC.Types.Double
                                           (GHC.Prim.-# ds1 1)
                                           ipv1 of ww1 { (#,#) ww2 ww3 ->
                                    case ww3 of wild2 {
                                      [] -> GHC.List.scanl2 @ GHC.Types.Double : ds2 xs -> xs } }
                                 1
                                 -> case ipv1 of wild2 {
                                      [] -> GHC.List.scanl2 @ GHC.Types.Double : ds2 xs -> xs } } }
                       GHC.Types.True
                       -> case w of wild {
                            [] -> GHC.List.scanl2 @ GHC.Types.Double : ds1 xs -> xs } }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 0) of wild1 {
                   GHC.Types.False
                   -> case w of wild {
                        []
                        -> GHC.Base.++
                             @ GHC.Types.Double
                             (GHC.Types.[] @ GHC.Types.Double)
                             (GHC.Types.: @ GHC.Types.Double a a1)
                        : ipv ipv1
                        -> case ww of ds1 {
                             DEFAULT
                             -> GHC.Base.++
                                  @ GHC.Types.Double
                                  (GHC.Types.:
                                     @ GHC.Types.Double
                                     ipv
                                     (case GHC.List.splitAt_$s$wsplitAt'
                                             @ GHC.Types.Double
                                             (GHC.Prim.-# ds1 1)
                                             ipv1 of ww1 { (#,#) ww2 ww3 ->
                                      ww2 }))
                                  (GHC.Types.: @ GHC.Types.Double a a1)
                             1
                             -> GHC.Base.++
                                  @ GHC.Types.Double
                                  (GHC.Types.:
                                     @ GHC.Types.Double
                                     ipv
                                     (GHC.Types.[] @ GHC.Types.Double))
                                  (GHC.Types.: @ GHC.Types.Double a a1) } }
                   GHC.Types.True -> GHC.Types.: @ GHC.Types.Double a a1 }) -}
a4ecafafcd50fa3019d1111da9482129
  $wdifferential ::
    ([GHC.Types.Double] -> GHC.Types.Double)
    -> [GHC.Types.Double] -> GHC.Prim.Int# -> [GHC.Types.Double]
  {- Arity: 3, Strictness: <L,C(U(U))><L,U><L,U>, Inline: [0],
     Unfolding: (\ w :: [GHC.Types.Double] -> GHC.Types.Double
                   w1 :: [GHC.Types.Double]
                   ww :: GHC.Prim.Int# ->
                 let {
                   y :: GHC.Prim.Int# = GHC.Prim.-# ww 1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># 0 y) of wild {
                   GHC.Types.False
                   -> let {
                        lvl1 :: GHC.Types.Double = w w1
                      } in
                      letrec {
                        go :: GHC.Prim.Int# -> [GHC.Types.Double]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ x :: GHC.Prim.Int# ->
                          GHC.Types.:
                            @ GHC.Types.Double
                            (case w (Main.$w$supdate
                                       w1
                                       x
                                       Main.epsilon) of wild1 { GHC.Types.D# x1 ->
                             case lvl1 of wild2 { GHC.Types.D# y1 ->
                             GHC.Types.D# (GHC.Prim./## (GHC.Prim.-## x1 y1) 1.0e-5) } })
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.==# x y) of wild1 {
                               GHC.Types.False -> go (GHC.Prim.+# x 1)
                               GHC.Types.True -> GHC.Types.[] @ GHC.Types.Double })
                      } in
                      go 0
                   GHC.Types.True -> GHC.Types.[] @ GHC.Types.Double }) -}
ae99924cb825fd4c25ef8d4e7a3eb5cb
  $wupdate :: GHC.Num.Num a => [a] -> GHC.Prim.Int# -> a -> [a]
  {- Arity: 4,
     Strictness: <L,1*U(1*C1(C1(U)),A,A,A,A,A,A)><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   w :: GHC.Num.Num a
                   w1 :: [a]
                   ww :: GHC.Prim.Int#
                   w2 :: a ->
                 let {
                   a1 :: a
                   = GHC.Num.+
                       @ a
                       w
                       (case GHC.Prim.tagToEnum#
                               @ GHC.Types.Bool
                               (GHC.Prim.<=# ww 0) of wild1 {
                          GHC.Types.False
                          -> case w1 of wild {
                               [] -> GHC.List.badHead @ a
                               : ipv ipv1
                               -> case ww of ds1 {
                                    DEFAULT
                                    -> case GHC.List.splitAt_$s$wsplitAt'
                                              @ a
                                              (GHC.Prim.-# ds1 1)
                                              ipv1 of ww1 { (#,#) ww2 ww3 ->
                                       case ww3 of wild2 {
                                         [] -> GHC.List.badHead @ a : x ds2 -> x } }
                                    1
                                    -> case ipv1 of wild2 {
                                         [] -> GHC.List.badHead @ a : x ds2 -> x } } }
                          GHC.Types.True
                          -> case w1 of wild { [] -> GHC.List.badHead @ a : x ds1 -> x } })
                       w2
                 } in
                 let {
                   a2 :: [a]
                   = case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# ww 0) of wild1 {
                       GHC.Types.False
                       -> case w1 of wild {
                            [] -> GHC.List.scanl2 @ a
                            : ipv ipv1
                            -> case ww of ds1 {
                                 DEFAULT
                                 -> case GHC.List.splitAt_$s$wsplitAt'
                                           @ a
                                           (GHC.Prim.-# ds1 1)
                                           ipv1 of ww1 { (#,#) ww2 ww3 ->
                                    case ww3 of wild2 { [] -> GHC.List.scanl2 @ a : ds2 xs -> xs } }
                                 1
                                 -> case ipv1 of wild2 {
                                      [] -> GHC.List.scanl2 @ a : ds2 xs -> xs } } }
                       GHC.Types.True
                       -> case w1 of wild { [] -> GHC.List.scanl2 @ a : ds1 xs -> xs } }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 0) of wild1 {
                   GHC.Types.False
                   -> case w1 of wild {
                        [] -> GHC.Base.++ @ a (GHC.Types.[] @ a) (GHC.Types.: @ a a1 a2)
                        : ipv ipv1
                        -> case ww of ds1 {
                             DEFAULT
                             -> GHC.Base.++
                                  @ a
                                  (GHC.Types.:
                                     @ a
                                     ipv
                                     (case GHC.List.splitAt_$s$wsplitAt'
                                             @ a
                                             (GHC.Prim.-# ds1 1)
                                             ipv1 of ww1 { (#,#) ww2 ww3 ->
                                      ww2 }))
                                  (GHC.Types.: @ a a1 a2)
                             1
                             -> GHC.Base.++
                                  @ a
                                  (GHC.Types.: @ a ipv (GHC.Types.[] @ a))
                                  (GHC.Types.: @ a a1 a2) } }
                   GHC.Types.True -> GHC.Types.: @ a a1 a2 }) -}
0044ec79f24c7e121288ae494b274a5e
  differential ::
    ([GHC.Types.Double] -> GHC.Types.Double)
    -> [GHC.Types.Double] -> GHC.Types.Int -> [GHC.Types.Double]
  {- Arity: 3, Strictness: <L,C(U(U))><L,U><S,1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: [GHC.Types.Double] -> GHC.Types.Double
                   w1 :: [GHC.Types.Double]
                   w2 :: GHC.Types.Int ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 Main.$wdifferential w w1 ww1 }) -}
b81c93bd49ae41fdd239187383e62e35
  epsilon :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 1.0e-5) -}
b795992cf06fc46ca5c38d9dddfa52ed
  find_min ::
    ([GHC.Types.Double] -> GHC.Types.Double)
    -> [GHC.Types.Double] -> [GHC.Types.Double] -> [GHC.Types.Double]
  {- Arity: 3, HasNoCafRefs, Strictness: <C(S),C(U(U))><S,U><L,U> -}
eb85f35cdcedb82964d2bb37918230d4
  h :: GHC.Types.Double
  {- Strictness: m, Unfolding: (Main.epsilon) -}
580e7dd22a702aadc7cd226b9e1b866b
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
c8d9974538447c582b15f1fad704b8af
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ s :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        Main.main19
                        GHC.Types.True
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        Main.main18
                        GHC.Types.True
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        Main.main17
                        GHC.Types.True
                        ipv2 of ds3 { (#,#) ipv4 ipv5 ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        Main.main16
                        GHC.Types.True
                        ipv4 of ds4 { (#,#) ipv6 ipv7 ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        Main.main11
                        GHC.Types.True
                        ipv6 of ds5 { (#,#) ipv8 ipv9 ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        Main.main9
                        GHC.Types.True
                        ipv8 of ds6 { (#,#) ipv10 ipv11 ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   Main.main2
                   GHC.Types.True
                   ipv10 } } } } } }) -}
b7363f9ba8f318ff66884abe6e7f5227
  main10 :: GHC.Base.String
  {- Unfolding: (GHC.Show.showList__
                   @ GHC.Types.Double
                   GHC.Float.$fShowDouble1
                   Main.main_minValues
                   (GHC.Types.[] @ GHC.Types.Char)) -}
c0aa7d78c59a6bc74dbf55d87420b3f2
  main11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "Initial value:  as = "#
                   Main.main12) -}
cdd25832576f73457327307325c112b4
  main12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.showList__3
                   Main.main13) -}
cb8d517e6cec50c94ec24c06186e488e
  main13 :: GHC.Base.String
  {- Unfolding: (Main.main15 Main.main14) -}
a93439a9d33d96f8982ba437f7dd96bc
  main14 :: [GHC.Types.Char]
  {- Unfolding: (Main.main_showl Main.main6) -}
ac3a35591e694068524032329f3ee341
  main15 :: GHC.Show.ShowS
  {- Unfolding: (GHC.Float.$w$sshowSignedFloat
                   GHC.Float.$fShowDouble_$sshowFloat
                   GHC.Float.minExpt
                   1.0) -}
4f9cbe59708c90cf43fe732cab0fba91
  main16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "Function:  f(x1, x2) = x1^2 + x2^2"#) -}
e436d99aa3c614e86888703f1a580859
  main17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "This sample is for multivariate function."#) -}
706c8cba79eab183526d431f6fbf1aad
  main18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "This program is sample of \"Gradient Method\"."#) -}
5daa52dc4a16e5093c86a7ccf48a7b68
  main19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8#
                   "-----Gradient method\\239\\188\\136\\229\\139\\190\\233\\133\\141\\230\\179\\149\\239\\188\\137for multivariate function-----\n"#) -}
a3cb31c6588d7677ab5b854ee1eab8e8
  main2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "f(x1, x2):  f(min) = "#
                   Main.main3) -}
c8ae918084ca7c2bfa5498f9e0c839d4
  main20 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.NTCo:IO[0] <()>_R))) -}
a669500812e1c1468dbdcf91b97b1fe0
  main3 :: [GHC.Types.Char]
  {- Unfolding: (case GHC.List.$w!!
                        @ GHC.Types.Double
                        Main.main_minValues
                        0 of wild { GHC.Types.D# x ->
                 case GHC.List.$w!!
                        @ GHC.Types.Double
                        Main.main_minValues
                        1 of wild1 { GHC.Types.D# x1 ->
                 GHC.Float.$w$sshowSignedFloat
                   GHC.Float.$fShowDouble_$sshowFloat
                   GHC.Show.shows18
                   (GHC.Prim.+## (GHC.Prim.*## x x) (GHC.Prim.*## x1 x1))
                   (GHC.Types.[] @ GHC.Types.Char) } }) -}
9af179c0e9731a7f1b4e84b93a534d1b
  main4 :: [GHC.Types.Double]
  {- Unfolding: (case GHC.List.$wlenAcc
                        @ GHC.Types.Double
                        Main.main_as
                        0 of ww2 { DEFAULT ->
                 Main.$wdifferential Main.main5 Main.main_as ww2 }) -}
f88d5600bb529ba9f40d1c73640396f0
  main5 :: [GHC.Types.Double] -> GHC.Types.Double
  {- Arity: 1,
     Unfolding: (\ xs :: [GHC.Types.Double] ->
                 case GHC.List.$w!!
                        @ GHC.Types.Double
                        xs
                        0 of wild { GHC.Types.D# x ->
                 case GHC.List.$w!!
                        @ GHC.Types.Double
                        xs
                        1 of wild1 { GHC.Types.D# x1 ->
                 GHC.Types.D#
                   (GHC.Prim.+## (GHC.Prim.*## x x) (GHC.Prim.*## x1 x1)) } }) -}
e3db9974200b80d18582cecfcf97f5c7
  main6 :: [GHC.Types.Double]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   Main.main7
                   (GHC.Types.[] @ GHC.Types.Double)) -}
bee3d5202b7f1f1903d274d949d8e450
  main7 :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 2.0) -}
159c017eaa28d5cb09eab4dffba7f7b4
  main8 :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 1.0) -}
0287194f650dbef6a506fce12fca543f
  main9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "Local minimum value:  min = "#
                   Main.main10) -}
c12ba8d3fc62cc495ac20ce269dfdf67
  main_as :: [GHC.Types.Double]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   Main.main8
                   Main.main6) -}
5a58158d26747f9043d6e9bac5dfe006
  main_minValues :: [GHC.Types.Double]
  {- Unfolding: (Main.find_min Main.main5 Main.main_as Main.main4) -}
9ccc80d40f5f30f5f9da85a97d650ea3
  main_showl :: [GHC.Types.Double] -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U> -}
edbf4389840a9dd6a7696594bcd9b76c
  update :: GHC.Num.Num a => [a] -> GHC.Types.Int -> a -> [a]
  {- Arity: 4,
     Strictness: <L,1*U(1*C1(C1(U)),A,A,A,A,A,A)><L,U><S,1*U(U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a w :: GHC.Num.Num a w1 :: [a] w2 :: GHC.Types.Int w3 :: a ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 Main.$wupdate @ a w w1 ww1 w3 }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False



==================== FINAL INTERFACE ====================
2016-06-13 13:56:53.182394 UTC

interface main@main:Main 7103
  interface hash: a3ccc8d3737669c05ed77b1b71fbadce
  ABI hash: 0a6f9d9a612364e4227abfd3c58d2c1a
  export-list hash: d60da6f2da4bfeef6b9a3f7d209a2529
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: db54b3632fd09afba7c6a9a34e8e01c5
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.differential
  Main.epsilon
  Main.find_min
  Main.h
  Main.main
  Main.update
module dependencies:
package dependencies: Gradient-Method-Multivariate-0.1.0.0@Gradi_JbP0S2lxg7W18AWNIWptfS
                      base-4.8.2.0* ghc-prim-0.4.0.0 integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  Gradient-Method-Multivariate-0.1.0.0@Gradi_JbP0S2lxg7W18AWNIWptfS:Lib 88cdd508206407129c1e8f25884eac51
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.Tuple 012ad951a59a9d85fe1de36a2f012986
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Real 1281efa9baf803bc7859d7efb89a38b3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:System.IO 0899686bfc1d9ef72dff3de85e99862a
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
00d91ea4556e8ba4be6535b2da08f84d
  $w$sf :: [GHC.Types.Double] -> GHC.Prim.Double#
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ w :: [GHC.Types.Double] ->
                 case GHC.List.$w!!
                        @ GHC.Types.Double
                        w
                        0 of wild { GHC.Types.D# x1 ->
                 case GHC.List.$w!!
                        @ GHC.Types.Double
                        w
                        2 of wild1 { GHC.Types.D# y ->
                 case GHC.List.$w!!
                        @ GHC.Types.Double
                        w
                        1 of wild2 { GHC.Types.D# y1 ->
                 case GHC.List.$w!!
                        @ GHC.Types.Double
                        w
                        3 of wild3 { GHC.Types.D# y2 ->
                 case GHC.List.$w!!
                        @ GHC.Types.Double
                        w
                        4 of wild4 { GHC.Types.D# x2 ->
                 let {
                   x3 :: GHC.Prim.Double# = GHC.Prim.-## x1 y
                 } in
                 let {
                   x4 :: GHC.Prim.Double# = GHC.Prim.+## x1 y1
                 } in
                 let {
                   x5 :: GHC.Prim.Double# = GHC.Prim.-## y1 1.0
                 } in
                 let {
                   x6 :: GHC.Prim.Double#
                   = GHC.Prim.-## (GHC.Prim.+## (GHC.Prim.+## y2 y2) x1) y1
                 } in
                 let {
                   x7 :: GHC.Prim.Double# = GHC.Prim.-## (GHC.Prim.+## x2 x1) y
                 } in
                 GHC.Prim.+##
                   (GHC.Prim.+##
                      (GHC.Prim.+##
                         (GHC.Prim.+## (GHC.Prim.*## x3 x3) (GHC.Prim.*## x4 x4))
                         (GHC.Prim.*## x5 x5))
                      (GHC.Prim.*## x6 x6))
                   (GHC.Prim.*## x7 x7) } } } } }) -}
896a626ac72aee22fe09620b3f7e1343
  $w$supdate ::
    [GHC.Types.Double]
    -> GHC.Prim.Int# -> GHC.Types.Double -> [GHC.Types.Double]
  {- Arity: 3, Strictness: <L,U><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ w :: [GHC.Types.Double]
                   ww :: GHC.Prim.Int#
                   w1 :: GHC.Types.Double ->
                 let {
                   a :: GHC.Types.Double
                   = case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# ww 0) of wild1 {
                       GHC.Types.False
                       -> case w of wild {
                            [] -> case GHC.List.badHead ret_ty GHC.Types.Double of {}
                            : ipv ipv1
                            -> case ww of ds1 {
                                 DEFAULT
                                 -> case GHC.List.splitAt_$s$wsplitAt'
                                           @ GHC.Types.Double
                                           (GHC.Prim.-# ds1 1)
                                           ipv1 of ww1 { (#,#) ww2 ww3 ->
                                    case ww3 of wild2 {
                                      [] -> case GHC.List.badHead ret_ty GHC.Types.Double of {}
                                      : x1 ds2
                                      -> case x1 of wild3 { GHC.Types.D# x2 ->
                                         case w1 of wild4 { GHC.Types.D# y ->
                                         GHC.Types.D# (GHC.Prim.+## x2 y) } } } }
                                 1
                                 -> case ipv1 of wild2 {
                                      [] -> case GHC.List.badHead ret_ty GHC.Types.Double of {}
                                      : x1 ds2
                                      -> case x1 of wild3 { GHC.Types.D# x2 ->
                                         case w1 of wild4 { GHC.Types.D# y ->
                                         GHC.Types.D# (GHC.Prim.+## x2 y) } } } } }
                       GHC.Types.True
                       -> case w of wild {
                            [] -> case GHC.List.badHead ret_ty GHC.Types.Double of {}
                            : x1 ds1
                            -> case x1 of wild2 { GHC.Types.D# x2 ->
                               case w1 of wild3 { GHC.Types.D# y ->
                               GHC.Types.D# (GHC.Prim.+## x2 y) } } } }
                 } in
                 let {
                   a1 :: [GHC.Types.Double]
                   = case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# ww 0) of wild1 {
                       GHC.Types.False
                       -> case w of wild {
                            [] -> GHC.List.scanl2 @ GHC.Types.Double
                            : ipv ipv1
                            -> case ww of ds1 {
                                 DEFAULT
                                 -> case GHC.List.splitAt_$s$wsplitAt'
                                           @ GHC.Types.Double
                                           (GHC.Prim.-# ds1 1)
                                           ipv1 of ww1 { (#,#) ww2 ww3 ->
                                    case ww3 of wild2 {
                                      [] -> GHC.List.scanl2 @ GHC.Types.Double : ds2 xs -> xs } }
                                 1
                                 -> case ipv1 of wild2 {
                                      [] -> GHC.List.scanl2 @ GHC.Types.Double : ds2 xs -> xs } } }
                       GHC.Types.True
                       -> case w of wild {
                            [] -> GHC.List.scanl2 @ GHC.Types.Double : ds1 xs -> xs } }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 0) of wild1 {
                   GHC.Types.False
                   -> case w of wild {
                        []
                        -> GHC.Base.++
                             @ GHC.Types.Double
                             (GHC.Types.[] @ GHC.Types.Double)
                             (GHC.Types.: @ GHC.Types.Double a a1)
                        : ipv ipv1
                        -> case ww of ds1 {
                             DEFAULT
                             -> GHC.Base.++
                                  @ GHC.Types.Double
                                  (GHC.Types.:
                                     @ GHC.Types.Double
                                     ipv
                                     (case GHC.List.splitAt_$s$wsplitAt'
                                             @ GHC.Types.Double
                                             (GHC.Prim.-# ds1 1)
                                             ipv1 of ww1 { (#,#) ww2 ww3 ->
                                      ww2 }))
                                  (GHC.Types.: @ GHC.Types.Double a a1)
                             1
                             -> GHC.Base.++
                                  @ GHC.Types.Double
                                  (GHC.Types.:
                                     @ GHC.Types.Double
                                     ipv
                                     (GHC.Types.[] @ GHC.Types.Double))
                                  (GHC.Types.: @ GHC.Types.Double a a1) } }
                   GHC.Types.True -> GHC.Types.: @ GHC.Types.Double a a1 }) -}
af8c0526d7897802fc33af539e02259f
  $wupdate :: GHC.Num.Num a => [a] -> GHC.Prim.Int# -> a -> [a]
  {- Arity: 4,
     Strictness: <L,1*U(1*C1(C1(U)),A,A,A,A,A,A)><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   w :: GHC.Num.Num a
                   w1 :: [a]
                   ww :: GHC.Prim.Int#
                   w2 :: a ->
                 let {
                   a1 :: a
                   = GHC.Num.+
                       @ a
                       w
                       (case GHC.Prim.tagToEnum#
                               @ GHC.Types.Bool
                               (GHC.Prim.<=# ww 0) of wild1 {
                          GHC.Types.False
                          -> case w1 of wild {
                               [] -> GHC.List.badHead @ a
                               : ipv ipv1
                               -> case ww of ds1 {
                                    DEFAULT
                                    -> case GHC.List.splitAt_$s$wsplitAt'
                                              @ a
                                              (GHC.Prim.-# ds1 1)
                                              ipv1 of ww1 { (#,#) ww2 ww3 ->
                                       case ww3 of wild2 {
                                         [] -> GHC.List.badHead @ a : x1 ds2 -> x1 } }
                                    1
                                    -> case ipv1 of wild2 {
                                         [] -> GHC.List.badHead @ a : x1 ds2 -> x1 } } }
                          GHC.Types.True
                          -> case w1 of wild { [] -> GHC.List.badHead @ a : x1 ds1 -> x1 } })
                       w2
                 } in
                 let {
                   a2 :: [a]
                   = case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# ww 0) of wild1 {
                       GHC.Types.False
                       -> case w1 of wild {
                            [] -> GHC.List.scanl2 @ a
                            : ipv ipv1
                            -> case ww of ds1 {
                                 DEFAULT
                                 -> case GHC.List.splitAt_$s$wsplitAt'
                                           @ a
                                           (GHC.Prim.-# ds1 1)
                                           ipv1 of ww1 { (#,#) ww2 ww3 ->
                                    case ww3 of wild2 { [] -> GHC.List.scanl2 @ a : ds2 xs -> xs } }
                                 1
                                 -> case ipv1 of wild2 {
                                      [] -> GHC.List.scanl2 @ a : ds2 xs -> xs } } }
                       GHC.Types.True
                       -> case w1 of wild { [] -> GHC.List.scanl2 @ a : ds1 xs -> xs } }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 0) of wild1 {
                   GHC.Types.False
                   -> case w1 of wild {
                        [] -> GHC.Base.++ @ a (GHC.Types.[] @ a) (GHC.Types.: @ a a1 a2)
                        : ipv ipv1
                        -> case ww of ds1 {
                             DEFAULT
                             -> GHC.Base.++
                                  @ a
                                  (GHC.Types.:
                                     @ a
                                     ipv
                                     (case GHC.List.splitAt_$s$wsplitAt'
                                             @ a
                                             (GHC.Prim.-# ds1 1)
                                             ipv1 of ww1 { (#,#) ww2 ww3 ->
                                      ww2 }))
                                  (GHC.Types.: @ a a1 a2)
                             1
                             -> GHC.Base.++
                                  @ a
                                  (GHC.Types.: @ a ipv (GHC.Types.[] @ a))
                                  (GHC.Types.: @ a a1 a2) } }
                   GHC.Types.True -> GHC.Types.: @ a a1 a2 }) -}
f1b23b876ba16a516ccc336d22229236
  $wxs :: GHC.Prim.Int# -> (# GHC.Types.Double, [GHC.Types.Double] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
417598214c2730c053bed10616c7e1f7
  differential ::
    ([GHC.Types.Double] -> GHC.Types.Double)
    -> [GHC.Types.Double] -> [GHC.Types.Double]
  {- Arity: 2, Strictness: <L,C(U(U))><S,U>,
     Unfolding: (\ f :: [GHC.Types.Double] -> GHC.Types.Double
                   as :: [GHC.Types.Double] ->
                 case GHC.List.$wlenAcc @ GHC.Types.Double as 0 of ww2 { DEFAULT ->
                 let {
                   y :: GHC.Prim.Int# = GHC.Prim.-# ww2 1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># 0 y) of wild {
                   GHC.Types.False
                   -> letrec {
                        go :: GHC.Prim.Int# -> [GHC.Types.Double]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ x1 :: GHC.Prim.Int# ->
                          GHC.Types.:
                            @ GHC.Types.Double
                            (case f (Main.$w$supdate
                                       as
                                       x1
                                       Main.h) of wild1 { GHC.Types.D# x2 ->
                             case f (Main.$w$supdate
                                       as
                                       x1
                                       Main.differential1) of wild2 { GHC.Types.D# y1 ->
                             GHC.Types.D# (GHC.Prim./## (GHC.Prim.-## x2 y1) 2.0e-7) } })
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.==# x1 y) of wild1 {
                               GHC.Types.False -> go (GHC.Prim.+# x1 1)
                               GHC.Types.True -> GHC.Types.[] @ GHC.Types.Double })
                      } in
                      go 0
                   GHC.Types.True -> GHC.Types.[] @ GHC.Types.Double } }) -}
35116d60104b32167c495367111c8165
  differential1 :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.D# -1.0e-7) -}
9eb76dd2e197d075a002293dc9c1cc53
  epsilon :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 1.0e-2) -}
877990d21d864aa1aecb0cfccb8fb07c
  find_min ::
    ([GHC.Types.Double] -> GHC.Types.Double)
    -> [GHC.Types.Double] -> [GHC.Types.Double]
  {- Arity: 2, Strictness: <C(S),C(U(U))><S,U> -}
381505592941c7a918f9017e87e5e77c
  h :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 1.0e-7) -}
b2ebb49844d67a7949c583d53821665d
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
d0976ddaef67cc02618a0369d8e7de69
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ s :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        Main.main11
                        GHC.Types.True
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        Main.main10
                        GHC.Types.True
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        Main.main9
                        GHC.Types.True
                        ipv2 of ds3 { (#,#) ipv4 ipv5 ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        Main.main8
                        GHC.Types.True
                        ipv4 of ds4 { (#,#) ipv6 ipv7 ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        Main.main6
                        GHC.Types.True
                        ipv6 of ds5 { (#,#) ipv8 ipv9 ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        Main.main4
                        GHC.Types.True
                        ipv8 of ds6 { (#,#) ipv10 ipv11 ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   Main.main2
                   GHC.Types.True
                   ipv10 } } } } } }) -}
c9f7bfcbe037647b877dd6ffe62e5c38
  main10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "This program is sample of \"Gradient Method\"."#) -}
9f519464a87f1ab3b515a4d961f75fb1
  main11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8#
                   "-----Gradient method\\239\\188\\136\\229\\139\\190\\233\\133\\141\\230\\179\\149\\239\\188\\137for multivariate function-----\n"#) -}
dac8f4c06627c39c3a4b8d61b901f2b5
  main12 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.NTCo:IO[0] <()>_R))) -}
02e361fde17c61f379929fd2da05dfb6
  main2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "f(x1, x2, x3, x4, x5):  f(min) = "#
                   Main.main3) -}
ba23a13b14051faa813f0f2c729b955a
  main3 :: [GHC.Types.Char]
  {- Unfolding: (case Main.$w$sf
                        Main.main_minValues of ww { DEFAULT ->
                 GHC.Float.$w$sshowSignedFloat
                   GHC.Float.$fShowDouble_$sshowFloat
                   GHC.Show.shows18
                   ww
                   (GHC.Types.[] @ GHC.Types.Char) }) -}
ee4bb4757fa47210696cac42a9042626
  main4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "Local minimum value:  min = "#
                   Main.main5) -}
23526ceba12b5e09aaa2c562c821c0db
  main5 :: GHC.Base.String
  {- Unfolding: (GHC.Show.showList__
                   @ GHC.Types.Double
                   GHC.Float.$fShowDouble1
                   Main.main_minValues
                   (GHC.Types.[] @ GHC.Types.Char)) -}
32631a8db0ab7f606dba68323784077c
  main6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "Initial value:  as = "#
                   Main.main7) -}
c19e05b45d783d81bc1cf05619c770d7
  main7 :: GHC.Base.String
  {- Unfolding: (GHC.Show.showList__
                   @ GHC.Types.Double
                   GHC.Float.$fShowDouble1
                   Main.main_as
                   (GHC.Types.[] @ GHC.Types.Char)) -}
63f562b3c6a7b53258f81e8901b5900d
  main8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "Function:  f(x1, x2, x3, x4, x5) = (x1 - x3)^2 + (x1 + x2)^2 + (x2 - 1)^2 + (2x4 + x1 - x2)^2 + (x5 + x1 - x3)^2"#) -}
3af6b0f148899b81cdc1963e36da14d7
  main9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "This sample is for multivariate function."#) -}
82f396556d9dd9e4c949ca25b894d3a7
  main_$sf :: [GHC.Types.Double] -> GHC.Types.Double
  {- Arity: 1, Strictness: <S,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Types.Double] ->
                 case Main.$w$sf w of ww { DEFAULT -> GHC.Types.D# ww }) -}
96246d4c78c0801b713b7e6fe5b11698
  main_as :: [GHC.Types.Double]
  {- Unfolding: (case Main.$wxs 5 of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ GHC.Types.Double ww1 ww2 }) -}
ebabd5499ef55c9cb19d1db3d5966e77
  main_minValues :: [GHC.Types.Double]
  {- Unfolding: (Main.find_min Main.main_$sf Main.main_as) -}
f0db69cfbb7ae85fa69092a8615092d2
  update :: GHC.Num.Num a => [a] -> GHC.Types.Int -> a -> [a]
  {- Arity: 4,
     Strictness: <L,1*U(1*C1(C1(U)),A,A,A,A,A,A)><L,U><S,1*U(U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a w :: GHC.Num.Num a w1 :: [a] w2 :: GHC.Types.Int w3 :: a ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 Main.$wupdate @ a w w1 ww1 w3 }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

